<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON SYMPHONY: EVOLVED</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; cursor: crosshair; user-select: none; }
        #canvas-container { width: 100%; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: radial-gradient(circle, rgba(0,0,0,0.4) 0%, #000 100%);
            transition: opacity 1s;
        }

        h1 {
            color: #fff; font-size: 5vw; margin: 0; font-weight: 100; letter-spacing: 10px;
            text-transform: uppercase; text-shadow: 0 0 30px #00ffff;
            animation: breathe 4s infinite ease-in-out;
        }

        .subtitle {
            color: #ff00ff; font-size: 1.2rem; letter-spacing: 5px; margin-top: 20px;
            text-transform: uppercase; border-top: 1px solid #ff00ff; padding-top: 10px;
        }

        #startBtn {
            margin-top: 50px; background: transparent; color: #fff; border: 1px solid #fff; 
            padding: 20px 60px; font-size: 1rem; letter-spacing: 3px; cursor: pointer;
            transition: all 0.3s;
        }
        #startBtn:hover { background: #fff; color: #000; box-shadow: 0 0 50px #fff; }

        /* HUD */
        .hud-bottom {
            position: absolute; bottom: 30px; left: 40px; 
            z-index: 10; pointer-events: none; opacity: 0; transition: opacity 1s;
            color: #888; font-size: 0.8rem; line-height: 1.6;
        }
        .val { color: #fff; font-weight: bold; text-shadow: 0 0 5px #fff; }
        
        .msg-box {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: 2rem; font-weight: 900; color: #fff; letter-spacing: 5px;
            text-shadow: 0 0 20px #00ffff; opacity: 0; transition: opacity 0.5s;
            pointer-events: none; z-index: 15;
        }

        .hint {
            position: absolute; bottom: 100px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 0.9rem; letter-spacing: 2px;
            pointer-events: none; opacity: 0; transition: opacity 1s; z-index: 15;
        }

        @keyframes breathe { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; text-shadow: 0 0 50px #00ffff; } }
    </style>
</head>
<body>

<div id="canvas-container"></div>
<div class="msg-box" id="msgBox">SEQUENCE START</div>
<div class="hint" id="hintBox">MOVE MOUSE UP TO EVOLVE</div>

<div class="ui-layer" id="ui">
    <h1>SYMPHONY</h1>
    <div class="subtitle">Generative Evolution</div>
    <button id="startBtn">INITIATE SYMPHONY</button>
</div>

<div class="hud-bottom" id="hud">
    COMPLEXITY: <span class="val" id="complexVal">1</span><br>
    KEY: <span class="val" id="keyVal">F# Minor</span><br>
    STRUCTURE: <span class="val" id="structVal">Intro</span>
</div>

<!-- SHADERS -->
<script type="x-shader/x-vertex" id="vShader">
    varying vec2 vUv;
    varying vec3 vColor;
    varying float vAlpha;

    uniform float uTime;
    uniform float uSpeed;
    uniform float uBass;
    uniform float uComplex; // Complexity 1.0 - 5.0

    attribute vec3 aColor;
    attribute float aOffset; 
    attribute float aSize;

    void main() {
        vUv = uv;
        vColor = aColor;

        vec3 pos = position;
        
        // Infinite Tunnel
        float zPos = mod(pos.z + uTime * uSpeed + aOffset, 1000.0) - 800.0;
        pos.z = zPos;

        // Evolving Geometry
        // Low complexity: Cylinder
        // High complexity: Twisted Organic Shape
        float angle = zPos * 0.005 * uComplex;
        float s = sin(angle);
        float c = cos(angle);
        
        float nx = pos.x * c - pos.y * s;
        float ny = pos.x * s + pos.y * c;
        
        // Expand based on complexity
        float expand = 1.0 + (sin(zPos * 0.02 + uTime) * 0.5 + 0.5) * (uComplex - 1.0) * 0.5;
        
        pos.x = nx * expand;
        pos.y = ny * expand;

        // Bass Pulse
        float pulse = 1.0 + uBass * 0.3 * smoothstep(-500.0, 0.0, zPos);
        pos.xy *= pulse;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_PointSize = aSize * (300.0 / -mvPosition.z) * (1.0 + uBass * 0.5);
        gl_Position = projectionMatrix * mvPosition;

        // Distance Fog
        vAlpha = smoothstep(-900.0, -700.0, zPos) * (1.0 - smoothstep(100.0, 200.0, zPos));
    }
</script>

<script type="x-shader/x-fragment" id="fShader">
    varying vec3 vColor;
    varying float vAlpha;
    uniform float uHigh;

    void main() {
        vec2 uv = gl_PointCoord.xy - 0.5;
        float dist = length(uv);
        if (dist > 0.5) discard;
        
        // Sparkle core
        float glow = 1.0 - (dist * 2.0);
        glow = pow(glow, 1.5);
        
        // Add brightness on High Frequencies
        vec3 finalColor = vColor + vec3(uHigh * 0.5);

        gl_FragColor = vec4(finalColor, vAlpha * glow);
    }
</script>

<script>
    // --- GLOBAL STATE ---
    let isPlaying = false;
    let mouseY = 0; // 0.0 to 1.0 (Energy/Evolution input)
    let complexity = 1.0; // Evolving complexity
    
    // --- MUSIC THEORY ENGINE ---
    const BASE_FREQ = 46.25; // F#1
    const NOTES = ["F#", "G", "G#", "A", "A#", "B", "C", "C#", "D", "D#", "E", "F"];
    const SCALE_MINOR = [0, 2, 3, 5, 7, 8, 10]; // Minor Intervals
    
    let currentRoot = 0; // Index in NOTES
    let currentScale = SCALE_MINOR;
    let currentChordDegree = 0; // 0 (i), 2 (III), 4 (v), etc.

    function getFreq(noteIndex, octave) {
        const semitones = noteIndex + (octave * 12) + currentRoot;
        return BASE_FREQ * Math.pow(2, semitones / 12);
    }

    function getScaleNote(degree, octave) {
        const octShift = Math.floor(degree / 7);
        const idx = degree % 7;
        const semi = currentScale[idx];
        return getFreq(semi, octave + octShift);
    }

    // --- SEQUENCER STATE ---
    let ac, master, filter, limiter, analyser, reverb;
    let nextNoteTime = 0;
    let measure = 0;
    let step = 0;
    
    // Generative Patterns
    let bassPattern = [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0];
    let melodyMotif = [0, 2, 4, 7]; // Scale degrees
    
    // Song Structure
    let section = "INTRO";
    let sectionTimer = 0;

    // --- 3D VISUALS ---
    let scene, camera, renderer, clock, tunnelPoints, uniforms;

    function init3D() {
        const container = document.getElementById('canvas-container');
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // PARTICLES
        const geo = new THREE.BufferGeometry();
        const count = 10000;
        const pos = [];
        const colors = [];
        const sizes = [];
        const offsets = [];

        const c1 = new THREE.Color(0x00ffff);
        const c2 = new THREE.Color(0xff00ff);

        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 30 + Math.random() * 60;
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            const z = (Math.random() - 0.5) * 2000;
            
            pos.push(x, y, z);
            sizes.push(Math.random() * 3.0 + 0.5);
            offsets.push(Math.random() * 1000);
            
            const col = Math.random() > 0.5 ? c1 : c2;
            colors.push(col.r, col.g, col.b);
        }

        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        geo.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geo.setAttribute('aOffset', new THREE.Float32BufferAttribute(offsets, 1));

        uniforms = {
            uTime: { value: 0 },
            uSpeed: { value: 50 },
            uBass: { value: 0 },
            uHigh: { value: 0 },
            uComplex: { value: 1.0 }
        };

        const mat = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: uniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        tunnelPoints = new THREE.Points(geo, mat);
        scene.add(tunnelPoints);

        window.addEventListener('resize', onWindowResize);
        document.addEventListener('mousemove', e => {
            mouseY = 1.0 - (e.clientY / window.innerHeight);
        });
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!clock) return;
        
        const time = clock.getElapsedTime();
        
        // Evolve Complexity based on Mouse Y + Music Phase
        let targetComplex = 1.0 + (mouseY * 3.0);
        if(section === "CLIMAX") targetComplex += 2.0;
        
        complexity += (targetComplex - complexity) * 0.05;
        
        uniforms.uTime.value = time;
        uniforms.uSpeed.value = 50 + (complexity * 100);
        uniforms.uComplex.value = complexity;

        if(analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);
            uniforms.uBass.value += ((data[2]/255) - uniforms.uBass.value) * 0.2;
            uniforms.uHigh.value += ((data[30]/255) - uniforms.uHigh.value) * 0.1;
        }

        // Camera Spiral
        camera.rotation.z = Math.sin(time * 0.1) * 0.2;

        renderer.render(scene, camera);
        
        // Update HUD
        document.getElementById('complexVal').innerText = complexity.toFixed(1);
    }

    // --- AUDIO ENGINE ---
    function initAudio() {
        ac = new (window.AudioContext || window.webkitAudioContext)();
        master = ac.createGain();
        master.gain.value = 0.5;

        // Filter controlled by Mouse + Envelopes
        filter = ac.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 2;

        limiter = ac.createDynamicsCompressor();
        limiter.threshold.value = -5;
        limiter.ratio.value = 20;

        // Reverb
        const len = ac.sampleRate * 3;
        const buf = ac.createBuffer(2, len, ac.sampleRate);
        for(let i=0; i<len; i++) {
            let d = (1 - i/len);
            buf.getChannelData(0)[i] = (Math.random()*2-1)*d;
            buf.getChannelData(1)[i] = (Math.random()*2-1)*d;
        }
        reverb = ac.createConvolver();
        reverb.buffer = buf;
        const revMix = ac.createGain();
        revMix.gain.value = 0.4;

        master.connect(filter);
        filter.connect(limiter);
        limiter.connect(ac.destination);
        filter.connect(reverb);
        reverb.connect(revMix);
        revMix.connect(limiter);

        analyser = ac.createAnalyser();
        analyser.fftSize = 64;
        limiter.connect(analyser);

        schedule();
    }

    // --- GENERATIVE COMPOSITION ---
    function evolveMusic() {
        // This function is called at section transitions
        
        // 1. Modulate Key (Up a fifth or fourth)
        if(Math.random() > 0.5) {
            currentRoot = (currentRoot + 7) % 12; // Circle of fifths
            showMsg("MODULATION: " + NOTES[currentRoot]);
            document.getElementById('keyVal').innerText = NOTES[currentRoot] + " Minor";
        }
        
        // 2. Evolve Bass Pattern
        if(complexity > 2) {
            // Euclidean-ish rhythm: 1 = hit, 0 = rest
            bassPattern = [1,0,1,0, 1,0,0,1, 1,0,1,0, 1,1,0,0];
        } else {
            bassPattern = [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0]; // Basic
        }
        
        // 3. Evolve Melody Motif
        // Add notes, change intervals
        motif = motif.map(n => n + (Math.random()>0.5 ? 1 : -1));
        // Ensure valid scale degrees
        motif = motif.map(n => Math.abs(n) % 7);
        if(motif.length < 8) motif.push(Math.floor(Math.random()*7)); // Grow length
    }

    function showMsg(text) {
        const el = document.getElementById('msgBox');
        el.innerText = text;
        el.style.opacity = 1;
        setTimeout(() => el.style.opacity = 0, 2000);
    }

    // --- INSTRUMENTS ---
    function playKick(t) {
        const osc = ac.createOscillator();
        const g = ac.createGain();
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
        g.gain.setValueAtTime(1.0, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g); g.connect(master); // Direct punch
        osc.start(t); osc.stop(t+0.3);
    }

    function playBass(t, freq) {
        const osc = ac.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);
        const f = ac.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.setValueAtTime(400, t);
        f.frequency.exponentialRampToValueAtTime(100, t + 0.2);
        const g = ac.createGain();
        g.gain.setValueAtTime(0.6, t);
        g.gain.linearRampToValueAtTime(0, t+0.2);
        osc.connect(f); f.connect(g); g.connect(master);
        osc.start(t); osc.stop(t+0.2);
    }

    function playArp(t, freq) {
        // Stereo Arp
        const osc = ac.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, t);
        const g = ac.createGain();
        g.gain.setValueAtTime(0.1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        
        const pan = ac.createStereoPanner();
        pan.pan.value = Math.sin(t * 5); // Auto-pan
        
        osc.connect(g); g.connect(pan); pan.connect(filter);
        osc.start(t); osc.stop(t+0.15);
    }

    function playPad(t, freq) {
        // SuperSaw Pad
        const g = ac.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.1, t+0.5);
        g.gain.linearRampToValueAtTime(0, t+2.0);
        
        // 3 osc unison
        [-5, 0, 5].forEach(d => {
            const o = ac.createOscillator();
            o.type = 'sawtooth';
            o.frequency.value = freq;
            o.detune.value = d;
            o.connect(g);
            o.start(t); o.stop(t+2.0);
        });
        g.connect(filter);
    }

    // --- SEQUENCER ---
    function schedule() {
        const tempo = 138;
        const sec16 = 60/tempo/4;
        const lookahead = 0.1;

        while(nextNoteTime < ac.currentTime + lookahead) {
            processStep(step, nextNoteTime);
            nextNoteTime += sec16;
            step++;
            if(step===16) {
                step=0; measure++;
                updateStructure();
            }
        }
        if(isPlaying) setTimeout(schedule, 25);
    }

    function updateStructure() {
        // 1. CHORD PROGRESSION
        if(measure % 4 === 0) {
            // Cycle through i - VI - III - VII
            currentChordDegree = [0, 5, 2, 6][(measure/4)%4];
        }

        // 2. SONG SECTIONS
        // Every 16 measures, change section
        if(measure % 16 === 0) {
            const sections = ["INTRO", "BUILD", "CLIMAX", "COOL"];
            const idx = Math.floor(measure/16) % sections.length;
            section = sections[idx];
            
            document.getElementById('structVal').innerText = section;
            
            if(section === "CLIMAX") {
                evolveMusic(); // Upgrade melody
                showMsg("CLIMAX REACHED");
            }
        }
    }

    function processStep(s, t) {
        // Mouse Filter Control override
        const targetF = 200 + (mouseY * 15000);
        filter.frequency.setTargetAtTime(targetF, t, 0.1);

        // 1. KICK
        let kickOn = (section !== "INTRO" && section !== "COOL");
        if(kickOn && s % 4 === 0) playKick(t);

        // 2. BASS
        // Use pattern
        if(section !== "INTRO") {
            if(bassPattern[s] === 1) {
                playBass(t, getScaleNote(currentChordDegree, 1));
            }
        }

        // 3. ARP (Melody)
        if(section === "BUILD" || section === "CLIMAX") {
            if(s % 2 === 0) {
                // Use motif relative to chord
                const motifNote = motif[(s/2) % motif.length];
                const note = getScaleNote(currentChordDegree + motifNote, 3);
                playArp(t, note);
            }
        }

        // 4. PAD
        if(s === 0 && measure % 2 === 0) {
            playPad(t, getScaleNote(currentChordDegree, 2));
            playPad(t, getScaleNote(currentChordDegree+2, 2)); // 3rd
        }
    }

    // --- INIT ---
    document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('ui').style.opacity = 0;
        setTimeout(() => document.getElementById('ui').style.display='none', 800);
        document.querySelector('.hud-bottom').style.opacity = 1;
        document.querySelector('.hud-top').style.opacity = 1;
        document.getElementById('hintBox').style.opacity = 1;
        setTimeout(() => document.getElementById('hintBox').style.opacity = 0, 4000);

        init3D();
        initAudio();
        
        if(ac.state === 'suspended') ac.resume();
        isPlaying = true;
        nextNoteTime = ac.currentTime + 0.1;
        
        schedule();
        animate();
    });

</script>
</body>
</html>
