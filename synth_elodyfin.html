<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SACRED GEOMETRY AUDIO</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100%; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: radial-gradient(circle, transparent 0%, #000 100%);
            pointer-events: none;
        }

        h1 {
            color: #fff; font-size: 4em; font-weight: 100; letter-spacing: 20px;
            text-transform: uppercase; margin: 0; opacity: 0.9;
            text-shadow: 0 0 40px rgba(255,255,255,0.2);
        }

        .subtitle {
            color: #d4af37; font-size: 1em; letter-spacing: 5px; margin-top: 20px;
            text-transform: uppercase;
        }

        button {
            pointer-events: auto; margin-top: 60px;
            background: transparent; color: #d4af37; 
            border: 1px solid #d4af37; padding: 15px 50px;
            font-family: inherit; font-size: 0.9em; letter-spacing: 4px; 
            cursor: pointer; transition: all 1s;
        }
        button:hover { background: rgba(212, 175, 55, 0.1); box-shadow: 0 0 50px rgba(212, 175, 55, 0.2); }

        .hud-bottom {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            z-index: 10; pointer-events: none; color: #444; font-size: 0.7em; letter-spacing: 3px;
        }
        
        #vis-status { color: #d4af37; opacity: 0; transition: opacity 2s; }

    </style>
</head>
<body>

<div id="canvas-container"></div>

<div class="ui-layer" id="ui">
    <h1>A E T H E R</h1>
    <div class="subtitle">Harmonic Series Engine</div>
    <button id="startBtn">HARMONIZE</button>
</div>

<div class="hud-bottom">
    <span id="vis-status">RESONANCE STABLE</span>
</div>

<!-- SHADER: Fibonacci Particles -->
<script type="x-shader/x-vertex" id="vShader">
    attribute float aIdx;
    attribute float aSize;
    
    uniform float uTime;
    uniform float uBass;
    uniform float uHigh;
    
    varying float vAlpha;
    varying vec3 vColor;

    // Golden Ratio
    const float PHI = 1.61803398875;
    const float PI = 3.14159265359;

    void main() {
        // Fibonacci Sphere Distribution
        // y goes from 1 to -1
        float y = 1.0 - (aIdx / 5000.0) * 2.0;
        float radius = sqrt(1.0 - y * y);
        float theta = PHI * aIdx * 2.0 * PI;
        
        float x = cos(theta) * radius;
        float z = sin(theta) * radius;
        
        vec3 pos = vec3(x, y, z);
        
        // Expansion (Breathing)
        float breathe = 1.0 + sin(uTime * 0.5 + pos.y * 2.0) * 0.1;
        // Audio Reactivity
        breathe += uBass * 0.5 * smoothstep(0.0, 1.0, abs(pos.y));
        
        pos *= 20.0 * breathe; // Scale up sphere
        
        // Rotation
        float rot = uTime * 0.1;
        float c = cos(rot); float s = sin(rot);
        // Rotate around Y
        vec3 finalPos = vec3(pos.x * c + pos.z * s, pos.y, -pos.x * s + pos.z * c);

        vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
        gl_PointSize = aSize * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;

        // Color Gradient based on Y position (Gold to Blue)
        vec3 gold = vec3(0.83, 0.68, 0.21);
        vec3 blue = vec3(0.1, 0.2, 0.4);
        vColor = mix(blue, gold, smoothstep(-1.0, 1.0, y + sin(uTime)*0.5));
        
        // Sparkle
        vAlpha = 0.5 + 0.5 * sin(uTime * 5.0 + aIdx);
    }
</script>

<script type="x-shader/x-fragment" id="fShader">
    varying float vAlpha;
    varying vec3 vColor;
    
    void main() {
        // Soft circle
        vec2 uv = gl_PointCoord.xy - 0.5;
        float dist = length(uv);
        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
        
        // Core glow
        vec3 finalColor = vColor + vec3(0.5) * (1.0 - dist*1.5);
        
        gl_FragColor = vec4(finalColor, alpha * vAlpha);
    }
</script>

<script>
    // --- STATE ---
    let isPlaying = false;
    let clock;

    // --- THREE.JS ---
    let scene, camera, renderer, particles, uniforms;
    
    function init3D() {
        const container = document.getElementById('canvas-container');
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 40;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // PARTICLE SYSTEM (5000 Particles on Fibonacci Sphere)
        const count = 5000;
        const geometry = new THREE.BufferGeometry();
        const indices = [];
        const sizes = [];
        
        for(let i=0; i<count; i++) {
            indices.push(i);
            sizes.push(1.0 + Math.random() * 2.0);
        }
        
        geometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(count*3), 3)); // Dummy pos
        geometry.setAttribute('aIdx', new THREE.Float32BufferAttribute(indices, 1));
        geometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));

        uniforms = {
            uTime: { value: 0 },
            uBass: { value: 0 },
            uHigh: { value: 0 }
        };

        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: uniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!clock) return;
        
        const time = clock.getElapsedTime();
        uniforms.uTime.value = time;

        // Audio Analysis for Visuals
        if(analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);
            
            // Smoothed values
            const bass = data[4] / 255.0; // Low frequency
            const high = data[64] / 255.0; // High frequency
            
            // Lerp for smoothness
            uniforms.uBass.value += (bass - uniforms.uBass.value) * 0.1;
            uniforms.uHigh.value += (high - uniforms.uHigh.value) * 0.1;
            
            // Subtle Camera drift based on high notes
            camera.rotation.z = Math.sin(time * 0.1) * 0.1 + (uniforms.uHigh.value * 0.05);
        }

        renderer.render(scene, camera);
    }

    // --- AUDIO ENGINE (PURE MATH) ---
    let ac, master, limiter;
    let reverbNode, analyser;
    
    // Just Intonation Scale (More consonant than equal temperament)
    // Frequencies derived from C3 = 130.81 Hz
    const FUNDAMENTAL = 130.81;
    // Ratios: 1/1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8, 2/1 (Major Scale)
    const RATIOS = [1, 9/8, 5/4, 1.333, 1.5, 1.666, 1.875, 2];
    
    function initAudio() {
        ac = new (window.AudioContext || window.webkitAudioContext)();
        master = ac.createGain();
        master.gain.value = 0.4;
        
        limiter = ac.createDynamicsCompressor();
        limiter.threshold.value = -3;
        limiter.ratio.value = 12;

        // Convolution Reverb (The "Cathedral")
        const len = ac.sampleRate * 4;
        const buf = ac.createBuffer(2, len, ac.sampleRate);
        for(let i=0; i<len; i++) {
            // Exponential decay for smooth tail
            const d = Math.pow(1 - i/len, 3);
            buf.getChannelData(0)[i] = (Math.random()*2-1)*d;
            buf.getChannelData(1)[i] = (Math.random()*2-1)*d;
        }
        reverbNode = ac.createConvolver();
        reverbNode.buffer = buf;
        
        const revMix = ac.createGain();
        revMix.gain.value = 0.5;

        master.connect(limiter);
        limiter.connect(ac.destination);
        master.connect(reverbNode);
        reverbNode.connect(revMix);
        revMix.connect(limiter);

        analyser = ac.createAnalyser();
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.9; // Very smooth
        limiter.connect(analyser);

        // Start Generative Process
        scheduleNextNote();
        startDrone();
    }

    // 1. ADDITIVE BELL SYNTH (Math Beauty)
    function playBell(freq, time) {
        if(!ac) return;
        
        // A bell sound is composed of non-integer harmonics
        // Ratios: 1, 2, 3, 4.2, 5.4 (Inharmonicity creates "glassy" sound)
        const harmonics = [1, 2, 3, 4.2];
        const amps = [1, 0.5, 0.3, 0.1];
        const decays = [1.5, 1.0, 0.8, 0.5];
        
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.2, time + 0.02); // Fast attack
        gain.gain.exponentialRampToValueAtTime(0.001, time + 3.0); // Long decay
        
        harmonics.forEach((h, i) => {
            const osc = ac.createOscillator();
            osc.type = 'sine'; // Pure sine waves
            osc.frequency.value = freq * h;
            
            const hGain = ac.createGain();
            hGain.gain.value = amps[i];
            
            osc.connect(hGain);
            hGain.connect(gain);
            osc.start(time);
            osc.stop(time + 3.0);
        });

        // Add a slight FM layer for "chime" attack
        const mod = ac.createOscillator();
        mod.frequency.value = freq * 2.5; // Modulator
        const modG = ac.createGain();
        modG.gain.setValueAtTime(500, time);
        modG.gain.exponentialRampToValueAtTime(0.01, time + 0.2); // Short blip
        
        const carrier = ac.createOscillator();
        carrier.frequency.value = freq;
        mod.connect(modG);
        modG.connect(carrier.frequency);
        carrier.connect(gain);
        mod.start(time); carrier.start(time);
        mod.stop(time+0.2); carrier.stop(time+0.2);
        
        gain.connect(master);
    }

    // 2. BINAURAL DRONE (Space)
    function startDrone() {
        const root = FUNDAMENTAL / 2; // C2
        
        // Two oscillators slightly detuned = Binaural beating
        const oscL = ac.createOscillator();
        const oscR = ac.createOscillator();
        oscL.type = 'triangle';
        oscR.type = 'triangle';
        
        oscL.frequency.value = root;
        oscR.frequency.value = root + 0.2; // 0.2Hz beat frequency (Theta waves)
        
        const panL = ac.createStereoPanner(); panL.pan.value = -0.8;
        const panR = ac.createStereoPanner(); panR.pan.value = 0.8;
        
        const gain = ac.createGain();
        gain.gain.value = 0;
        gain.gain.setTargetAtTime(0.15, ac.currentTime, 5); // Slow fade in
        
        // Filter movement
        const filter = ac.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        
        // LFO for filter
        const lfo = ac.createOscillator();
        lfo.frequency.value = 0.1; // Slow breathing
        const lfoG = ac.createGain();
        lfoG.gain.value = 100;
        lfo.connect(lfoG);
        lfoG.connect(filter.frequency);
        lfo.start();

        oscL.connect(panL); panL.connect(filter);
        oscR.connect(panR); panR.connect(filter);
        filter.connect(gain);
        gain.connect(master);
        
        oscL.start();
        oscR.start();
    }

    // --- GENERATIVE COMPOSER (MARKOV CHAIN SIMPLIFIED) ---
    // Instead of random, we use weighted probability for next note
    // Current note index -> probabilities for next note index
    let currentNoteIdx = 0;
    
    function getNextNote() {
        // Simple rules:
        // Tend to move by small steps (stepwise motion)
        // Tend to return to root (0) or 5th (4)
        
        const r = Math.random();
        let step = 0;
        
        if (r < 0.3) step = 0; // Repeat
        else if (r < 0.6) step = 1; // Up 1 scale degree
        else if (r < 0.8) step = -1; // Down 1
        else if (r < 0.9) step = 2; // Jump up 3rd
        else step = -2; // Jump down 3rd
        
        let nextIdx = currentNoteIdx + step;
        
        // Keep within 2 octaves (0 to 14)
        if (nextIdx < 0) nextIdx = 0;
        if (nextIdx > 14) nextIdx = 14;
        
        currentNoteIdx = nextIdx;
        
        // Map index to frequency (Ratio * Fundamental)
        const octave = Math.floor(nextIdx / 7);
        const degree = nextIdx % 7;
        const ratio = RATIOS[degree];
        
        return FUNDAMENTAL * Math.pow(2, octave) * ratio;
    }

    function scheduleNextNote() {
        if(!isPlaying) return;
        
        const now = ac.currentTime;
        const freq = getNextNote();
        
        // Polyrhythm Timing: Play every 0.3 to 1.5 seconds randomly, but synced to a grid?
        // Let's use Golden Ratio timing
        const wait = 0.2 + Math.random() * 0.8; 
        
        playBell(freq * 2, now); // Octave up for bell
        
        // Occasionally play a bass note
        if(Math.random() > 0.7) {
            playBell(freq / 2, now + 0.1);
        }

        setTimeout(scheduleNextNote, wait * 1000);
    }

    // --- INIT ---
    document.getElementById('startBtn').addEventListener('click', () => {
        const ui = document.getElementById('ui');
        ui.style.opacity = 0;
        setTimeout(() => ui.style.display = 'none', 2000);
        
        document.getElementById('vis-status').style.opacity = 1;

        init3D();
        initAudio();
        
        if(ac.state === 'suspended') ac.resume();
        isPlaying = true;
        animate();
    });

</script>
</body>
</html>
