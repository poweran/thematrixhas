<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON SYMPHONY: EVOLVED</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; cursor: crosshair; user-select: none; }
        #canvas-container { width: 100%; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: radial-gradient(circle, rgba(0,0,0,0.4) 0%, #000 100%);
            transition: opacity 1s;
        }

        h1 {
            color: #fff; font-size: 5vw; margin: 0; font-weight: 100; letter-spacing: 10px;
            text-transform: uppercase; text-shadow: 0 0 30px #00ffff;
            animation: breathe 4s infinite ease-in-out;
        }

        .subtitle {
            color: #ff00ff; font-size: 1.2rem; letter-spacing: 5px; margin-top: 20px;
            text-transform: uppercase; border-top: 1px solid #ff00ff; padding-top: 10px;
        }

        #startBtn {
            margin-top: 50px; background: transparent; color: #fff; border: 1px solid #fff; 
            padding: 20px 60px; font-size: 1rem; letter-spacing: 3px; cursor: pointer;
            transition: all 0.3s;
        }
        #startBtn:hover { background: #fff; color: #000; box-shadow: 0 0 50px #fff; }

        /* HUD */
        .hud { position: absolute; padding: 20px; color: #fff; font-family: monospace; z-index: 10; pointer-events: none; opacity: 0; transition: opacity 1s; }
        .hud-top { top: 0; width: 100%; text-align: center; }
        .hud-bottom { bottom: 0; left: 0; width: 100%; display: flex; justify-content: space-between; box-sizing: border-box; }
        
        .phase-label { font-size: 3rem; font-weight: 900; letter-spacing: 5px; text-shadow: 0 0 20px #ff00ff; }
        .data-val { color: #00ffff; font-weight: bold; }
        
        .bar-container { width: 200px; height: 5px; background: #333; margin-top: 5px; }
        .bar-fill { width: 0%; height: 100%; background: #00ffff; box-shadow: 0 0 10px #00ffff; transition: width 0.1s; }

    </style>
</head>
<body>

<div id="canvas-container"></div>

<div class="ui-layer" id="ui">
    <h1>EUPHORIA</h1>
    <button id="startBtn">INITIATE SYSTEM</button>
</div>

<div class="hud hud-top" id="hudTop">
    <div class="phase-label" id="phaseDisplay">WAITING</div>
</div>

<div class="hud hud-bottom" id="hudBottom">
    <div>
        FILTER: <span class="data-val" id="filterVal">0%</span>
        <div class="bar-container"><div class="bar-fill" id="filterBar"></div></div>
    </div>
    <div style="text-align:right">
        ENERGY: <span class="data-val" id="energyVal">0%</span>
        <div class="bar-container"><div class="bar-fill" id="energyBar" style="float:right"></div></div>
    </div>
</div>

<!-- SHADERS -->
<script type="x-shader/x-vertex" id="vShader">
    varying vec2 vUv;
    varying float vDist;
    uniform float uTime;
    uniform float uSpeed;
    uniform float uBass;
    uniform float uTwist;

    void main() {
        vUv = uv;
        vec3 pos = position;
        
        // Infinite Tunnel
        float z = mod(pos.z + uTime * uSpeed, 1000.0) - 800.0;
        pos.z = z;

        // Twist Logic
        float angle = z * 0.005 * uTwist;
        float s = sin(angle);
        float c = cos(angle);
        float nx = pos.x * c - pos.y * s;
        float ny = pos.x * s + pos.y * c;
        pos.x = nx;
        pos.y = ny;

        // Bass Pulse
        float pulse = 1.0 + uBass * 0.3 * smoothstep(-500.0, 0.0, z);
        pos.xy *= pulse;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_PointSize = (8.0 + uBass * 15.0) * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
        vDist = z;
    }
</script>

<script type="x-shader/x-fragment" id="fShader">
    varying float vDist;
    uniform float uBass;
    uniform float uHigh;
    uniform vec3 uColor1;
    uniform vec3 uColor2;

    void main() {
        vec2 uv = gl_PointCoord.xy - 0.5;
        if(length(uv) > 0.5) discard;
        
        // Dynamic Color Mixing
        vec3 col = mix(uColor1, uColor2, vDist/200.0 + 0.5);
        col += vec3(uBass * 0.5); // Flash on kick

        // Distance Fog
        float alpha = smoothstep(-900.0, -800.0, vDist) * (1.0 - smoothstep(100.0, 200.0, vDist));
        
        // Core glow
        float core = 1.0 - length(uv) * 2.0;
        gl_FragColor = vec4(col * 1.5, alpha * core);
    }
</script>

<script>
    // --- MUSIC THEORY: F# MINOR ---
    const SCALE = [46.25, 55.0, 65.41, 82.41, 98.0, 110.0, 130.81]; // F#1 Pentatonic
    // Chords: F#m -> D -> A -> E (Classic Euphoric)
    const CHORDS = [
        [0, 2, 4], // F# A C#
        [5, 7, 9], // D F# A
        [2, 4, 6], // A C# E
        [6, 8, 10] // E G# B
    ];
    // "Anthem" Melody Motif (Scale Degrees)
    const MOTIF = [4, 2, 0, 2, 4, 2, 4, 7, 6, 5, 2, 0];

    // --- STATE ---
    let isPlaying = false;
    let ac, master, compressor, reverb, filter;
    let analyser;
    let clock;
    
    // Control State
    let mouseX = 0, mouseY = 0; // -1 to 1, 0 to 1
    let filterFreq = 200;
    let currentPhase = 0;
    
    // Sequencer
    let nextTime = 0;
    let step = 0;
    let measure = 0;
    let chordIdx = 0;

    // Phases
    const PHASES = [
        { name: "ATMOSPHERE", bars: 8,  kick:0, bass:0, arp:1, pad:1, speed: 50 },
        { name: "RISING",     bars: 16, kick:1, bass:1, arp:1, pad:1, speed: 200 }, // Snare roll logic handled in loop
        { name: "THE DROP",   bars: 32, kick:1, bass:1, arp:1, pad:1, speed: 600, lead:1 },
        { name: "BREAKDOWN",  bars: 16, kick:0, bass:0, arp:0, pad:1, speed: 100 }
    ];
    let phaseStartMeasure = 0;

    // --- 3D VISUALS ---
    let scene, camera, renderer, tunnelPoints, uniforms;

    function init3D() {
        const container = document.getElementById('canvas-container');
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // Particle System
        const geo = new THREE.BufferGeometry();
        const pos = [];
        for(let i=0; i<15000; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 30 + Math.random() * 50;
            pos.push(Math.cos(angle)*r, Math.sin(angle)*r, (Math.random()-0.5)*2000);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

        uniforms = {
            uTime: { value: 0 },
            uSpeed: { value: 50 },
            uBass: { value: 0 },
            uHigh: { value: 0 },
            uTwist: { value: 0 },
            uColor1: { value: new THREE.Color(0x00ffff) },
            uColor2: { value: new THREE.Color(0xff00ff) }
        };

        const mat = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: uniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        tunnelPoints = new THREE.Points(geo, mat);
        scene.add(tunnelPoints);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('mousemove', e => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = 1.0 - (e.clientY / window.innerHeight);
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!clock) return;
        const time = clock.getElapsedTime();
        const dt = clock.getDelta();

        // 1. Audio Analysis
        let bass = 0, high = 0;
        if(analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);
            bass = data[2] / 255.0; 
            high = data[30] / 255.0;
        }

        // 2. Phase Logic
        const phase = PHASES[currentPhase];
        let targetSpeed = phase.speed;
        let targetTwist = mouseX * 2.0;

        // Visual smoothing
        uniforms.uTime.value = time;
        uniforms.uSpeed.value += (targetSpeed - uniforms.uSpeed.value) * 0.05;
        uniforms.uBass.value = bass;
        uniforms.uTwist.value += (targetTwist - uniforms.uTwist.value) * 0.1;
        
        // Colors based on mouse Y (Energy Control)
        const energy = mouseY;
        uniforms.uColor1.value.setHSL(0.5 + energy * 0.1, 1.0, 0.5); // Cyan -> Blue
        uniforms.uColor2.value.setHSL(0.8 + energy * 0.2, 1.0, 0.5); // Magenta -> Red

        // Camera Shake
        if(bass > 0.6) {
            camera.position.x = (Math.random()-0.5) * bass;
            camera.position.y = (Math.random()-0.5) * bass;
        }

        renderer.render(scene, camera);
        
        // HUD
        document.getElementById('filterVal').innerText = Math.floor(energy * 100) + "%";
        document.getElementById('filterBar').style.width = (energy * 100) + "%";
        document.getElementById('energyVal').innerText = phase.name;
    }

    // --- AUDIO ENGINE ---
    function initAudio() {
        ac = new (window.AudioContext || window.webkitAudioContext)();
        master = ac.createGain();
        master.gain.value = 0.5;

        // Filter controlled by Mouse Y
        filter = ac.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 2;

        compressor = ac.createDynamicsCompressor();
        compressor.threshold.value = -10;
        compressor.ratio.value = 12;

        // Stereo Delay
        const delayL = ac.createDelay(); delayL.delayTime.value = 0.3;
        const delayR = ac.createDelay(); delayR.delayTime.value = 0.45;
        const delayFb = ac.createGain(); delayFb.gain.value = 0.4;
        
        // Reverb
        const verb = ac.createConvolver();
        const len = ac.sampleRate * 3;
        const buf = ac.createBuffer(2, len, ac.sampleRate);
        for(let i=0;i<len;i++) {
            let d = (1-i/len);
            buf.getChannelData(0)[i]=(Math.random()*2-1)*d;
            buf.getChannelData(1)[i]=(Math.random()*2-1)*d;
        }
        verb.buffer = buf;
        const verbMix = ac.createGain(); verbMix.gain.value = 0.4;

        // Routing
        master.connect(filter);
        filter.connect(compressor);
        compressor.connect(ac.destination);
        
        // FX Sends
        filter.connect(verb); verb.connect(verbMix); verbMix.connect(compressor);
        filter.connect(delayL); filter.connect(delayR);
        delayL.connect(delayFb); delayR.connect(delayFb);
        delayFb.connect(delayL); delayFb.connect(delayR); // Feedback loop
        delayL.connect(compressor); delayR.connect(compressor);

        analyser = ac.createAnalyser();
        analyser.fftSize = 128;
        compressor.connect(analyser);

        schedule();
    }

    // --- SYNTHS ---
    function playSuperSaw(freq, t, dur, vol, panX) {
        const g = ac.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(vol, t+0.05);
        g.gain.exponentialRampToValueAtTime(0.001, t+dur);

        const p = ac.createStereoPanner();
        p.pan.value = panX;

        [-10, -5, 0, 5, 10].forEach(d => {
            const o = ac.createOscillator();
            o.type = 'sawtooth';
            o.frequency.value = freq;
            o.detune.value = d;
            o.connect(g);
            o.start(t); o.stop(t+dur);
        });

        g.connect(p); p.connect(master);
    }

    function playAcidBass(freq, t) {
        const o = ac.createOscillator();
        o.type = 'sawtooth';
        o.frequency.value = freq;
        
        const f = ac.createBiquadFilter();
        f.type = 'lowpass';
        f.Q.value = 10;
        f.frequency.setValueAtTime(100, t);
        f.frequency.linearRampToValueAtTime(800, t+0.1);
        f.frequency.linearRampToValueAtTime(100, t+0.2);

        const g = ac.createGain();
        g.gain.setValueAtTime(0.5, t);
        g.gain.linearRampToValueAtTime(0, t+0.2);

        o.connect(f); f.connect(g); g.connect(master);
        o.start(t); o.stop(t+0.2);
    }

    function playKick(t) {
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.frequency.setValueAtTime(150, t);
        o.frequency.exponentialRampToValueAtTime(40, t+0.1);
        g.gain.setValueAtTime(1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t+0.4);
        o.connect(g); g.connect(master);
        o.start(t); o.stop(t+0.4);
    }

    function playNoise(t, dur, type) {
        const b = ac.createBuffer(1, ac.sampleRate*dur, ac.sampleRate);
        const d = b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        const s = ac.createBufferSource(); s.buffer=b;
        
        const f = ac.createBiquadFilter();
        if(type==='snare') { f.type='highpass'; f.frequency.value=1000; }
        else { f.type='bandpass'; f.frequency.value=2000; } // Rise

        const g = ac.createGain();
        g.gain.setValueAtTime(type==='rise'?0:0.3, t);
        if(type==='rise') g.gain.linearRampToValueAtTime(0.5, t+dur);
        else g.gain.exponentialRampToValueAtTime(0.001, t+dur);

        s.connect(f); f.connect(g); g.connect(master);
        s.start(t);
    }

    // --- SEQUENCER ---
    function schedule() {
        const tempo = 138;
        const sec16 = 60/tempo/4;
        const lookahead = 0.1;

        while(nextTime < ac.currentTime + lookahead) {
            playStep(step, nextTime);
            nextTime += sec16;
            step++;
            if(step===16) {
                step=0; measure++;
                if(measure % 4 === 0) chordIdx = (chordIdx + 1) % CHORDS.length;
                updatePhase();
            }
        }
        if(isPlaying) setTimeout(schedule, 25);
    }

    function updatePhase() {
        const p = PHASES[currentPhase];
        if(measure >= phaseStartMeasure + p.bars) {
            currentPhase = (currentPhase + 1) % PHASES.length;
            phaseStartMeasure = measure;
            const newP = PHASES[currentPhase];
            document.getElementById('phaseDisplay').innerText = newP.name;
            
            // Auto-Riser on transition
            if(newP.name === "THE DROP") playNoise(ac.currentTime, 2.0, 'rise');
        }
    }

    function playStep(s, t) {
        const p = PHASES[currentPhase];
        
        // Dynamic Filter Control (Mouse Y)
        const targetFreq = 100 + (Math.pow(mouseY, 2) * 15000);
        filter.frequency.setTargetAtTime(targetFreq, t, 0.1);

        // 1. Kick
        if(p.kick && s%4===0) playKick(t);

        // 2. Bass (Acid)
        if(p.bass && s%4===2) playAcidBass(SCALE[0], t);

        // 3. Arp / Melody
        if(p.arp && s%2===0) {
            const chord = CHORDS[chordIdx];
            const noteIdx = MOTIF[(measure*8 + s/2) % MOTIF.length]; // Walk motif
            // Map motif index to chord tone approximation
            const freq = SCALE[noteIdx % SCALE.length] * 2;
            playSuperSaw(freq, t, 0.1, 0.1, Math.sin(t*5));
        }

        // 4. Pad / Chords (Big wall)
        if(p.pad && s===0) {
             CHORDS[chordIdx].forEach(idx => {
                 playSuperSaw(SCALE[idx], t, 2.0, 0.15, 0); // Long sustain
             });
        }
        
        // 5. Build-up Snare
        if(p.name === "RISING" && measure % 8 > 6) {
            if(s%2===0) playNoise(t, 0.05, 'snare'); // Snare roll
        }
    }

    // --- BOOT ---
    document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('ui').style.opacity = 0;
        setTimeout(()=>document.getElementById('ui').style.display='none', 1000);
        document.querySelector('.hud').style.opacity = 1;
        
        if(ac && ac.state === 'suspended') ac.resume();
        else {
            init3D();
            initAudio();
            isPlaying = true;
            nextTime = ac.currentTime + 0.1;
            
            // Set initial state
            document.getElementById('phaseDisplay').innerText = PHASES[0].name;

            animate();
        }
    });
</script>
</body>
</html>
