<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON ODYSSEY: INFINITY</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Layer */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85);
            transition: opacity 0.5s;
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #fff; font-size: 5vw; margin: 0;
            text-transform: uppercase; letter-spacing: 5px; font-weight: 900;
            text-shadow: 0 0 20px #00ffff, 4px 4px 0px #ff00ff;
            animation: glitch 3s infinite;
        }

        .subtitle {
            color: #00ffff; font-size: 1.2rem; letter-spacing: 5px; margin-top: 10px;
            border-top: 2px solid #00ffff; padding-top: 10px;
        }

        button {
            pointer-events: auto; margin-top: 50px;
            background: transparent; color: #fff; border: 2px solid #fff; 
            padding: 20px 60px; font-size: 1.5rem; font-weight: bold; 
            cursor: pointer; text-transform: uppercase; letter-spacing: 3px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            transition: all 0.2s;
        }
        button:hover { background: #fff; color: #000; box-shadow: 0 0 60px #00ffff; transform: scale(1.05); }

        #resetBtn {
            margin-top: 20px; border: none; font-size: 0.8rem; color: #666;
            background: none; box-shadow: none; text-decoration: underline;
        }
        #resetBtn:hover { color: #ff0055; background: none; box-shadow: none; transform: none; }

        /* HUD */
        .hud {
            position: absolute; width: 100%; z-index: 10; pointer-events: none;
            opacity: 0; transition: opacity 1s;
        }
        .hud-top { top: 30px; text-align: center; }
        .hud-bottom { bottom: 30px; left: 30px; text-align: left; color: #888; font-size: 0.9rem; }
        
        .score-val { font-size: 3rem; color: #fff; font-weight: 900; text-shadow: 0 0 20px #00ffff; }
        .label { font-size: 0.8rem; color: #00ffff; letter-spacing: 2px; }
        .val-text { color: #fff; font-weight: bold; text-shadow: 0 0 5px #fff; }

        .save-notif {
            position: absolute; bottom: 30px; right: 30px; color: #00ff00;
            font-weight: bold; opacity: 0; transition: opacity 0.5s;
        }

        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<!-- UI -->
<div class="ui-layer" id="ui">
    <h1>NEON<br>ODYSSEY</h1>
    <div class="subtitle">Infinite Progression</div>
    <button id="startBtn">INITIATE LINK</button>
    <button id="resetBtn">RESET SAVE DATA</button>
</div>

<!-- HUD -->
<div class="hud hud-top" id="hudTop">
    <div class="score-val" id="scoreDisplay">0</div>
    <div class="label">NEURAL SYNC</div>
</div>

<div class="hud hud-bottom" id="hudBottom">
    CYCLE: <span class="val-text" id="cycleDisplay">1</span><br>
    PHASE: <span class="val-text" id="phaseDisplay">STANDBY</span><br>
    FILTER: <span class="val-text" id="filterDisplay">0%</span>
</div>

<div class="save-notif" id="saveNotif">CHECKPOINT SAVED</div>

<!-- SHADERS -->
<script type="x-shader/x-vertex" id="vShader">
    varying vec2 vUv;
    varying float vDepth;
    uniform float uTime;
    uniform float uSpeed;
    uniform float uBass;

    void main() {
        vUv = uv;
        vec3 pos = position;
        
        // Infinite Tunnel Movement
        // Move Z towards camera (positive), wrap around
        float z = mod(pos.z + uTime * uSpeed, 1000.0) - 800.0;
        pos.z = z;

        // Warping
        float twist = z * 0.002;
        float s = sin(twist + uTime * 0.5);
        float c = cos(twist + uTime * 0.5);
        float nx = pos.x * c - pos.y * s;
        float ny = pos.x * s + pos.y * c;
        pos.x = nx;
        pos.y = ny;

        // Bass Expansion
        float pulse = 1.0 + uBass * 0.2;
        pos.xy *= pulse;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        gl_PointSize = (10.0 + uBass * 20.0) * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
        
        vDepth = z;
    }
</script>

<script type="x-shader/x-fragment" id="fShader">
    varying float vDepth;
    uniform float uBass;
    
    void main() {
        // Round particles
        vec2 uv = gl_PointCoord.xy - 0.5;
        if(length(uv) > 0.5) discard;
        
        // Color based on depth and bass
        vec3 colA = vec3(0.0, 1.0, 1.0); // Cyan
        vec3 colB = vec3(1.0, 0.0, 1.0); // Magenta
        
        float depthFactor = smoothstep(-800.0, 0.0, vDepth);
        vec3 finalColor = mix(colB, colA, depthFactor);
        
        // Flash white on bass
        finalColor += vec3(uBass * 0.5);

        // Fog fade
        float alpha = smoothstep(-900.0, -700.0, vDepth) * (1.0 - smoothstep(100.0, 200.0, vDepth));

        gl_FragColor = vec4(finalColor, alpha);
    }
</script>

<script>
    // --- SAVE SYSTEM ---
    const STORAGE_KEY = 'neon_odyssey_v2_save';
    
    let gameData = {
        score: 0,
        cycle: 1,
        highScore: 0
    };

    function saveGame() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(gameData));
        showSaveIcon();
    }

    function loadGame() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if(saved) {
            try {
                gameData = JSON.parse(saved);
                document.getElementById('startBtn').innerText = "RESUME CYCLE " + gameData.cycle;
            } catch(e) { console.error("Save corrupted"); }
        }
        updateHUD();
    }

    function resetSave() {
        localStorage.removeItem(STORAGE_KEY);
        gameData = { score: 0, cycle: 1, highScore: 0 };
        updateHUD();
        document.getElementById('startBtn').innerText = "INITIATE LINK";
    }

    function showSaveIcon() {
        const el = document.getElementById('saveNotif');
        if(el) {
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 1000);
        }
    }

    // --- GLOBAL VARIABLES ---
    let isPlaying = false;
    let isBoosting = false;
    let scoreAccumulator = 0; // For float score
    
    // Three.js
    let scene, camera, renderer, clock;
    let tunnelPoints, uniforms;
    
    // Audio
    let ac, master, filter, limiter, analyser;
    let reverb;
    
    // Sequencer
    let nextNoteTime = 0;
    let current16th = 0;
    let measure = 0;
    
    // Progression
    const PHASES = [
        { name: "WARMUP", bars: 8,  kick: false, bass: true,  arp: false, speed: 50,  filter: 200 },
        { name: "ASCENT", bars: 16, kick: true,  bass: true,  arp: true,  speed: 150, filter: 800 },
        { name: "CLIMAX", bars: 32, kick: true,  bass: true,  arp: true,  speed: 400, filter: 5000 },
        { name: "DRIFT",  bars: 8,  kick: false, bass: true,  arp: false, speed: 80,  filter: 300 }
    ];
    let phaseIndex = 0;
    let phaseStartMeasure = 0;

    // --- 3D ENGINE ---
    function init3D() {
        const container = document.getElementById('canvas-container');
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // Tunnel Particles
        const geo = new THREE.BufferGeometry();
        const count = 10000;
        const pos = [];
        
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 20 + Math.random() * 60;
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            const z = (Math.random() - 0.5) * 2000;
            pos.push(x, y, z);
        }
        
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));

        uniforms = {
            uTime: { value: 0 },
            uSpeed: { value: 50 },
            uBass: { value: 0 }
        };

        const mat = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: uniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        tunnelPoints = new THREE.Points(geo, mat);
        scene.add(tunnelPoints);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Boost Input
        const boostOn = () => { if(isPlaying) isBoosting = true; };
        const boostOff = () => { isBoosting = false; };
        document.addEventListener('mousedown', boostOn);
        document.addEventListener('mouseup', boostOff);
        document.addEventListener('touchstart', (e) => { e.preventDefault(); boostOn(); }, {passive:false});
        document.addEventListener('touchend', (e) => { e.preventDefault(); boostOff(); });
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!clock) return;
        
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();
        
        // 1. Logic Update
        const currentP = PHASES[phaseIndex];
        let targetSpeed = currentP.speed * (1 + (gameData.cycle * 0.1)); // Speed up per cycle
        let targetFilter = currentP.filter;

        if (isBoosting) {
            targetSpeed *= 3;
            targetFilter = 15000; // Full open
            gameData.score += dt * 100; // Bonus score
        } else {
            gameData.score += dt * 10; // Passive score
        }
        
        // Update HUD
        updateHUD();

        // 2. Uniforms
        uniforms.uTime.value = time;
        uniforms.uSpeed.value += (targetSpeed - uniforms.uSpeed.value) * 0.05;
        
        // Audio Reactivity
        if(analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);
            const bass = data[2] / 255.0;
            uniforms.uBass.value += (bass - uniforms.uBass.value) * 0.2;
            
            // Audio Filter Smoothing
            if (masterFilter) {
                // Use SetTarget for smooth audio transition
                masterFilter.frequency.setTargetAtTime(targetFilter, ac.currentTime, 0.2);
            }
            
            // Camera Shake
            if (bass > 0.6) {
                const shake = (bass - 0.6) * 1.0;
                camera.position.x = (Math.random()-0.5) * shake;
                camera.position.y = (Math.random()-0.5) * shake;
            }
        }
        
        // Camera Spiral
        camera.rotation.z = Math.sin(time * 0.1) * 0.2;

        renderer.render(scene, camera);
    }

    function updateHUD() {
        const sEl = document.getElementById('scoreDisplay');
        const cEl = document.getElementById('cycleDisplay');
        const pEl = document.getElementById('phaseDisplay');
        const fEl = document.getElementById('filterDisplay');

        if(sEl) sEl.innerText = Math.floor(gameData.score).toString().padStart(6, '0');
        if(cEl) cEl.innerText = gameData.cycle;
        if(pEl && PHASES[phaseIndex]) pEl.innerText = PHASES[phaseIndex].name;
        if(fEl && masterFilter) {
            const pct = Math.min(100, Math.floor((masterFilter.frequency.value / 20000) * 100));
            fEl.innerText = pct + "%";
        }
    }

    // --- AUDIO ENGINE ---
    // Scale: D Minor (D, E, F, G, A, Bb, C)
    const SCALE = [73.42, 82.41, 87.31, 98.00, 110.00, 116.54, 130.81];

    function initAudio() {
        ac = new (window.AudioContext || window.webkitAudioContext)();
        master = ac.createGain();
        master.gain.value = 0.5;

        masterFilter = ac.createBiquadFilter();
        masterFilter.type = 'lowpass';
        masterFilter.frequency.value = 200;
        masterFilter.Q.value = 2;

        limiter = ac.createDynamicsCompressor();
        limiter.threshold.value = -3;
        limiter.ratio.value = 20;

        // Reverb
        const len = ac.sampleRate * 2;
        const buf = ac.createBuffer(2, len, ac.sampleRate);
        for(let i=0; i<len; i++) {
            let d = (1 - i/len);
            buf.getChannelData(0)[i] = (Math.random()*2-1)*d;
            buf.getChannelData(1)[i] = (Math.random()*2-1)*d;
        }
        reverb = ac.createConvolver();
        reverb.buffer = buf;
        const revMix = ac.createGain();
        revMix.gain.value = 0.4;

        master.connect(masterFilter);
        masterFilter.connect(limiter);
        limiter.connect(ac.destination);
        masterFilter.connect(reverb);
        reverb.connect(revMix);
        revMix.connect(limiter);

        analyser = ac.createAnalyser();
        analyser.fftSize = 64;
        limiter.connect(analyser);
    }

    // --- INSTRUMENTS ---
    function playKick(t) {
        const osc = ac.createOscillator();
        const g = ac.createGain();
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
        g.gain.setValueAtTime(1.0, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g); g.connect(master);
        osc.start(t); osc.stop(t+0.3);
    }

    function playBass(t, freq) {
        const osc = ac.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);
        
        const f = ac.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.setValueAtTime(400, t);
        f.frequency.exponentialRampToValueAtTime(100, t + 0.2);
        
        const g = ac.createGain();
        g.gain.setValueAtTime(0.5, t);
        g.gain.linearRampToValueAtTime(0, t+0.2);
        osc.connect(f); f.connect(g); g.connect(master);
        osc.start(t); osc.stop(t+0.2);
    }

    function playArp(t, freq) {
        const osc = ac.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, t);
        const g = ac.createGain();
        g.gain.setValueAtTime(0.1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        osc.connect(g); g.connect(masterFilter);
        osc.start(t); osc.stop(t+0.1);
    }

    function playPad(t, freq) {
        const osc = ac.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);
        const g = ac.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.05, t + 0.5);
        g.gain.linearRampToValueAtTime(0, t + 2.0);
        osc.connect(g); g.connect(masterFilter);
        osc.start(t); osc.stop(t+2.0);
    }

    // --- SEQUENCER ---
    let motif = [0, 2, 4, 1]; // Evolving melody motif

    function schedule() {
        const tempo = 138 + (gameData.cycle * 2);
        const secPer16th = 60/tempo/4;
        const lookahead = 0.1;

        while(nextNoteTime < ac.currentTime + lookahead) {
            processStep(current16th, nextNoteTime);
            nextNoteTime += secPer16th;
            current16th++;
            if(current16th === 16) {
                current16th = 0;
                measure++;
                checkPhase();
                
                // SAVE every 4 measures
                if (measure % 4 === 0) saveGame();
            }
        }
        if(isPlaying) setTimeout(schedule, 25);
    }

    function checkPhase() {
        const p = PHASES[phaseIndex];
        if (measure >= phaseStartMeasure + p.bars) {
            phaseIndex++;
            if (phaseIndex >= PHASES.length) {
                phaseIndex = 0;
                gameData.cycle++;
                saveGame();
                // Evolve Motif
                motif = motif.map(n => (n + Math.floor(Math.random()*3)) % SCALE.length);
            }
            phaseStartMeasure = measure;
        }
    }

    function processStep(step, t) {
        const p = PHASES[phaseIndex];

        // 1. Kick
        if (p.kick && step % 4 === 0) playKick(t);

        // 2. Bass (Offbeat)
        if (p.bass && step % 4 === 2) {
            playBass(t, SCALE[0]);
        }

        // 3. Arp (Evolving)
        if (p.arp && step % 2 === 0) {
            const noteIdx = motif[(step/2) % 4];
            let freq = SCALE[noteIdx] * 2;
            
            // Add complexity with cycles
            if (gameData.cycle > 2 && step % 4 === 0) freq *= 2; 
            if (isBoosting) freq *= 1.5; // Pitch shift on boost

            playArp(t, freq);
        }
        
        // 4. Pad
        if (p.pad && step === 0 && measure % 2 === 0) {
            playPad(t, SCALE[0]); // Root drone
        }
    }

    // --- BOOT ---
    document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('ui').style.opacity = 0;
        setTimeout(() => document.getElementById('ui').style.display = 'none', 800);
        
        document.getElementById('hudTop').style.opacity = 1;
        document.getElementById('hudBottom').style.opacity = 1;

        init3D();
        initAudio();
        
        if (ac.state === 'suspended') ac.resume();
        isPlaying = true;
        nextNoteTime = ac.currentTime + 0.1;
        
        schedule();
        animate();
    });
    
    document.getElementById('resetBtn').addEventListener('click', resetSave);

</script>
</body>
</html>
