<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEON ODYSSEY: ASCENSION</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Courier New', monospace; cursor: crosshair; 
            user-select: none;
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: #000;
            transition: opacity 0.8s ease-in-out;
        }

        h1 {
            color: #fff; font-size: 5vw; margin: 0; line-height: 1;
            text-transform: uppercase; font-weight: 900; letter-spacing: 10px;
            text-shadow: 0 0 30px #00ffff;
            animation: pulse-slow 3s infinite;
        }

        .subtitle {
            color: #ff00ff; font-size: 1.2rem; letter-spacing: 5px; margin-top: 20px;
            text-transform: uppercase; border-top: 1px solid #ff00ff; padding-top: 10px;
        }

        #startBtn {
            margin-top: 60px;
            background: transparent; color: #fff; border: 1px solid #fff; 
            padding: 20px 80px; font-size: 1.2rem; font-weight: bold; 
            cursor: pointer; text-transform: uppercase; letter-spacing: 5px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            transition: all 0.3s;
        }
        #startBtn:hover { 
            background: #fff; color: #000; 
            box-shadow: 0 0 80px #00ffff; letter-spacing: 8px;
        }
        
        #resetBtn {
            margin-top: 20px; font-size: 0.8em; color: #666; border: none; background: none; cursor: pointer; text-decoration: underline;
        }
        #resetBtn:hover { color: #ff0055; }

        /* HUD */
        .hud-top {
            position: absolute; top: 30px; left: 0; width: 100%; text-align: center;
            z-index: 10; pointer-events: none; opacity: 0; transition: opacity 1s;
        }
        .phase-text {
            color: #fff; font-size: 2rem; font-weight: 900; letter-spacing: 5px;
            text-shadow: 0 0 20px #ff00ff;
        }
        .progress-bar-container {
            width: 300px; height: 4px; background: #333; margin: 10px auto;
        }
        .progress-bar {
            width: 0%; height: 100%; background: #00ffff; box-shadow: 0 0 10px #00ffff;
            transition: width 0.1s linear;
        }

        .hud-bottom {
            position: absolute; bottom: 30px; left: 40px; 
            z-index: 10; pointer-events: none; opacity: 0; transition: opacity 1s;
            color: #888; font-size: 0.8rem;
        }
        .val { color: #fff; font-weight: bold; text-shadow: 0 0 5px #fff; }

        .save-icon {
            position: absolute; bottom: 30px; right: 40px; color: #00ff00;
            font-size: 0.8rem; opacity: 0; transition: opacity 0.5s;
            z-index: 10; pointer-events: none;
        }

        @keyframes pulse-slow {
            0%, 100% { filter: brightness(100%) drop-shadow(0 0 10px #00ffff); }
            50% { filter: brightness(150%) drop-shadow(0 0 30px #00ffff); }
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div class="ui-layer" id="ui">
    <h1>NEON<br>ODYSSEY</h1>
    <div class="subtitle">Ascension Protocol</div>
    <button id="startBtn">INITIATE SEQUENCE</button>
    <button id="resetBtn">RESET DATA</button>
</div>

<div class="hud-top" id="hudTop">
    <div class="phase-text" id="phaseText">SYSTEM CHECK</div>
    <div class="progress-bar-container"><div class="progress-bar" id="progressBar"></div></div>
</div>

<div class="hud-bottom" id="hudBottom">
    CYCLE: <span class="val" id="cycleVal">1</span><br>
    SCORE: <span class="val" id="scoreVal">0</span><br>
    FILTER: <span class="val" id="filterVal">0%</span><br>
    SPEED: <span class="val" id="energyVal">0%</span>
</div>

<div class="save-icon" id="saveIcon">DATA SAVED</div>

<!-- VERTEX SHADER -->
<script type="x-shader/x-vertex" id="vShader">
    varying vec2 vUv;
    varying vec3 vColor;
    varying float vAlpha;

    uniform float uTime;
    uniform float uSpeed;
    uniform float uWarp;     
    uniform float uBass;

    attribute float aSize;
    attribute vec3 aColor;
    attribute float aOffset; 

    void main() {
        vUv = uv;
        vColor = aColor;

        vec3 pos = position;
        
        // Infinite Tunnel Movement
        float zPos = mod(pos.z + uTime * uSpeed + aOffset, 1000.0) - 800.0;
        pos.z = zPos;

        // Warp/Twist based on progression
        float angle = pos.z * 0.002 * uWarp;
        float s = sin(angle);
        float c = cos(angle);
        float nx = pos.x * c - pos.y * s;
        float ny = pos.x * s + pos.y * c;
        pos.x = nx;
        pos.y = ny;

        // Bass Pulse expansion
        float pulse = 1.0 + uBass * 0.2 * smoothstep(-500.0, 0.0, zPos);
        pos.xy *= pulse;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        
        // Dynamic Point Size
        gl_PointSize = aSize * (400.0 / -mvPosition.z) * (1.0 + uBass);
        gl_Position = projectionMatrix * mvPosition;

        // Fog calculation
        vAlpha = smoothstep(-900.0, -700.0, zPos) * (1.0 - smoothstep(50.0, 200.0, zPos));
    }
</script>

<!-- FRAGMENT SHADER -->
<script type="x-shader/x-fragment" id="fShader">
    varying vec3 vColor;
    varying float vAlpha;

    void main() {
        vec2 uv = gl_PointCoord.xy - 0.5;
        float dist = length(uv);
        float alpha = 1.0 - smoothstep(0.1, 0.5, dist);
        
        vec3 finalColor = vColor + vec3(0.5) * (1.0 - dist*2.0);
        gl_FragColor = vec4(finalColor, vAlpha * alpha);
    }
</script>

<script>
    // --- GLOBAL VARIABLES ---
    let isPlaying = false;
    let isBoosting = false; 
    
    // Save Data
    let gameData = {
        score: 0,
        cycle: 1, // "Level"
        totalTime: 0
    };

    // Audio State
    let ac, master, masterFilter, limiter;
    let reverbNode;
    let clock;
    let analyser;
    let saveInterval;
    
    // Sequencer State
    let nextNoteTime = 0;
    let current16th = 0;
    let measure = 0;
    let currentPhase = null;
    let phaseStartMeasure = 0;
    
    // Visual State
    let scene, camera, renderer;
    let tunnelSystem, uniforms;
    
    // Arrangement Generator
    const PHASE_TYPES = ["BUILD", "DROP", "BREAK", "EVOLVE"];
    let phaseSequence = ["BUILD", "DROP", "BREAK", "EVOLVE"];
    let phaseIndex = 0;
    
    function generatePhase(type) {
        // Procedurally generate parameters based on Cycle count
        const intensityMult = 1 + (gameData.cycle * 0.25); 
        
        if (type === "BUILD") {
            return { name: "UPLINK " + gameData.cycle, bars: 8, kick: true, bass: true, arp: true, pad: true, lead: false, filter: 0.4, speed: 100 * intensityMult };
        } else if (type === "DROP") {
            return { name: "VELOCITY " + gameData.cycle, bars: 16, kick: true, bass: true, arp: true, pad: true, lead: true, filter: 1.0, speed: 600 * intensityMult };
        } else if (type === "BREAK") {
            return { name: "VOID", bars: 8, kick: false, bass: false, arp: true, pad: true, lead: true, filter: 0.3, speed: 50 };
        } else { // EVOLVE (Transition)
            return { name: "EVOLUTION", bars: 8, kick: true, bass: false, arp: false, pad: true, lead: false, filter: 0.5, speed: 200 * intensityMult };
        }
    }

    // --- SAVE SYSTEM ---
    function loadGame() {
        const saved = localStorage.getItem('neon_odyssey_save');
        if (saved) {
            try {
                gameData = JSON.parse(saved);
                console.log("Save loaded:", gameData);
                // Ensure values are numbers
                gameData.score = Number(gameData.score) || 0;
                gameData.cycle = Number(gameData.cycle) || 1;
                updateHUD();
            } catch(e) {
                console.error("Save file corrupted", e);
                resetGame();
            }
        }
        // If loaded, update UI text to reflect resume
        if (gameData.cycle > 1 || gameData.score > 0) {
            const btn = document.getElementById('startBtn');
            if (btn) btn.innerText = "RESUME CYCLE " + gameData.cycle;
        }
    }

    function saveGame() {
        localStorage.setItem('neon_odyssey_save', JSON.stringify(gameData));
        const icon = document.getElementById('saveIcon');
        if(icon) {
            icon.style.opacity = 1;
            setTimeout(() => icon.style.opacity = 0, 1000);
        }
    }

    function resetGame() {
        localStorage.removeItem('neon_odyssey_save');
        gameData = { score: 0, cycle: 1, totalTime: 0 };
        updateHUD();
        const btn = document.getElementById('startBtn');
        if(btn) btn.innerText = "INITIATE SEQUENCE";
    }

    function updateHUD() {
        const cycleEl = document.getElementById('cycleVal');
        const scoreEl = document.getElementById('scoreVal');
        if (cycleEl) cycleEl.innerText = gameData.cycle;
        if (scoreEl) scoreEl.innerText = Math.floor(gameData.score);
    }

    // --- 3D ENGINE ---
    function init3D() {
        const container = document.getElementById('canvas-container');
        clock = new THREE.Clock();
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // PARTICLE SYSTEM
        const geo = new THREE.BufferGeometry();
        const count = 15000;
        const pos = [];
        const sizes = [];
        const colors = [];
        const offsets = [];

        const c1 = new THREE.Color(0x00ffff);
        const c2 = new THREE.Color(0xff00ff);
        const c3 = new THREE.Color(0xffffff);

        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 20 + Math.random() * 50;
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            const z = (Math.random() - 0.5) * 2000;
            
            pos.push(x, y, z);
            sizes.push(Math.random() * 2.0 + 0.5);
            offsets.push(Math.random() * 1000);

            const mix = Math.random();
            const col = mix > 0.9 ? c3 : c1.clone().lerp(c2, mix);
            colors.push(col.r, col.g, col.b);
        }

        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geo.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        geo.setAttribute('aOffset', new THREE.Float32BufferAttribute(offsets, 1));

        uniforms = {
            uTime: { value: 0 },
            uSpeed: { value: 0 },
            uWarp: { value: 0 },
            uBass: { value: 0 }
        };

        const mat = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: uniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        tunnelSystem = new THREE.Points(geo, mat);
        scene.add(tunnelSystem);

        window.addEventListener('resize', onWindowResize);
        document.addEventListener('mousedown', () => isBoosting = true);
        document.addEventListener('mouseup', () => isBoosting = false);
        document.addEventListener('touchstart', (e) => { e.preventDefault(); isBoosting = true; }, {passive:false});
        document.addEventListener('touchend', (e) => { e.preventDefault(); isBoosting = false; });
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!clock) return;
        
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();

        // Use current phase data or default
        const phase = currentPhase || { speed: 20, filter: 0.1 };
        
        let targetSpeed = phase.speed;
        let targetWarp = phase.filter * 5.0;
        
        if (isBoosting) {
            targetSpeed *= 2.0;
            targetWarp += 5.0;
            gameData.score += dt * 100; // Bonus points
        } else {
            gameData.score += dt * 10; // Passive points
        }
        
        // Update score visually (throttled to avoid layout thrashing ideally, but ok here)
        const scoreEl = document.getElementById('scoreVal');
        if (scoreEl) scoreEl.innerText = Math.floor(gameData.score);

        uniforms.uSpeed.value += (targetSpeed - uniforms.uSpeed.value) * 0.05;
        uniforms.uWarp.value += (targetWarp - uniforms.uWarp.value) * 0.05;
        uniforms.uTime.value = time;

        if(analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);
            const bass = data[3] / 255.0; 
            uniforms.uBass.value += (bass - uniforms.uBass.value) * 0.2;
            
            if(bass > 0.6) {
                const shake = (bass - 0.6) * 0.5;
                camera.position.x = (Math.random()-0.5) * shake;
                camera.position.y = (Math.random()-0.5) * shake;
            }
        }

        camera.rotation.z = Math.sin(time * 0.1) * 0.2;
        renderer.render(scene, camera);
        
        const filterP = Math.floor(masterFilter ? masterFilter.frequency.value / 200 : 0);
        
        const elFilter = document.getElementById('filterVal');
        if(elFilter) elFilter.innerText = filterP + "%";
        
        const elEnergy = document.getElementById('energyVal');
        if(elEnergy) elEnergy.innerText = Math.floor(uniforms.uSpeed.value / 10) + "%";
    }

    // --- AUDIO ENGINE ---
    // RICH HARMONIC SCALE (F Minor Extended)
    // F2, G2, Ab2, Bb2, C3, Db3, Eb3
    const ROOT = 43.65; // F1
    // Harmonic Series ratios derived scale
    const SCALE = [
        ROOT * 2, // F2
        ROOT * 2 * 1.2, // Ab2
        ROOT * 2 * 1.5, // C3
        ROOT * 4, // F3
        ROOT * 4 * 1.2, // Ab3
        ROOT * 4 * 1.5, // C3
        ROOT * 8, // F4
        ROOT * 8 * 1.25 // A4 (Major lift occasionally?)
    ];

    function initAudio() {
        ac = new (window.AudioContext || window.webkitAudioContext)();
        master = ac.createGain();
        master.gain.value = 0.5;

        masterFilter = ac.createBiquadFilter();
        masterFilter.type = 'lowpass';
        masterFilter.frequency.value = 200; 
        masterFilter.Q.value = 3;

        limiter = ac.createDynamicsCompressor();
        limiter.threshold.value = -5;
        limiter.ratio.value = 20;

        const len = ac.sampleRate * 3;
        const buf = ac.createBuffer(2, len, ac.sampleRate);
        for(let i=0; i<len; i++) {
            let d = (1 - i/len);
            buf.getChannelData(0)[i] = (Math.random()*2-1)*d;
            buf.getChannelData(1)[i] = (Math.random()*2-1)*d;
        }
        reverbNode = ac.createConvolver();
        reverbNode.buffer = buf;
        const revMix = ac.createGain();
        revMix.gain.value = 0.4;

        master.connect(masterFilter);
        masterFilter.connect(limiter);
        limiter.connect(ac.destination);
        masterFilter.connect(reverbNode);
        reverbNode.connect(revMix);
        revMix.connect(limiter);

        analyser = ac.createAnalyser();
        analyser.fftSize = 64;
        limiter.connect(analyser);
    }

    // --- INSTRUMENTS ---
    function playKick(t) {
        const osc = ac.createOscillator();
        const g = ac.createGain();
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
        g.gain.setValueAtTime(1.5, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g); g.connect(master);
        osc.start(t); osc.stop(t+0.3);
    }

    function playBass(t, freq) {
        const osc = ac.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);
        
        const f = ac.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.setValueAtTime(800, t);
        f.frequency.exponentialRampToValueAtTime(100, t + 0.2);
        f.Q.value = 5; // Acid resonance
        
        const g = ac.createGain();
        g.gain.setValueAtTime(0.6, t);
        g.gain.linearRampToValueAtTime(0, t+0.2);
        
        osc.connect(f); f.connect(g); g.connect(master);
        osc.start(t); osc.stop(t+0.2);
    }

    function playArp(t, freq) {
        const osc = ac.createOscillator();
        osc.type = 'square';
        osc.frequency.setValueAtTime(freq, t);
        
        const g = ac.createGain();
        g.gain.setValueAtTime(0.15, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        
        // Stereo spread
        const pan = ac.createStereoPanner();
        pan.pan.value = Math.sin(t * 10);
        
        osc.connect(g); g.connect(pan); pan.connect(masterFilter);
        osc.start(t); osc.stop(t+0.1);
    }

    function playPad(t, freq, dur) {
        // SuperSaw Pad Chord
        const osc1 = ac.createOscillator(); osc1.type = 'sawtooth';
        const osc2 = ac.createOscillator(); osc2.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.frequency.value = freq * 1.5; // 5th
        
        osc1.detune.value = -10;
        osc2.detune.value = 10;

        const g = ac.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.1, t + 0.5);
        g.gain.linearRampToValueAtTime(0, t + dur);
        
        osc1.connect(g); osc2.connect(g);
        g.connect(masterFilter);
        osc1.start(t); osc1.stop(t+dur);
        osc2.start(t); osc2.stop(t+dur);
    }
    
    function playLead(t, freq) {
        // Soaring Lead
        const osc = ac.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);
        // Portamento slide from previous note simulation
        osc.frequency.linearRampToValueAtTime(freq * 1.01, t + 0.5); 
        
        const g = ac.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.1, t + 0.05);
        g.gain.linearRampToValueAtTime(0, t + 0.5);
        
        const delay = ac.createDelay();
        delay.delayTime.value = 0.25;
        
        osc.connect(g); g.connect(masterFilter); g.connect(delay); delay.connect(masterFilter);
        osc.start(t); osc.stop(t+0.5);
    }

    function playNoiseSweep(t, dur) {
        const bSize = ac.sampleRate * dur;
        const b = ac.createBuffer(1, bSize, ac.sampleRate);
        const d = b.getChannelData(0);
        for(let i=0;i<bSize;i++) d[i]=Math.random()*2-1;
        const src = ac.createBufferSource();
        src.buffer = b;
        const f = ac.createBiquadFilter();
        f.type='bandpass'; f.Q.value=5;
        f.frequency.setValueAtTime(200, t);
        f.frequency.exponentialRampToValueAtTime(8000, t+dur);
        const g = ac.createGain();
        g.gain.setValueAtTime(0.2, t);
        g.gain.linearRampToValueAtTime(0, t+dur);
        src.connect(f); f.connect(g); g.connect(master);
        src.start(t);
    }

    // --- INFINITE SEQUENCER ---
    function schedule() {
        const tempo = 138 + (gameData.cycle * 2); 
        const secPer16th = 60/tempo/4;
        const lookahead = 0.1;

        while(nextNoteTime < ac.currentTime + lookahead) {
            processStep(current16th, nextNoteTime);
            nextNoteTime += secPer16th;
            current16th++;
            if(current16th === 16) {
                current16th = 0;
                measure++;
                updateProgression();
            }
        }
        if(isPlaying) setTimeout(schedule, 25);
    }

    function updateProgression() {
        if (!currentPhase || measure >= phaseStartMeasure + currentPhase.bars) {
            
            const type = phaseSequence[phaseIndex % phaseSequence.length];
            phaseIndex++;
            
            if (type === "EVOLVE") {
                gameData.cycle++;
                saveGame();
            }
            
            currentPhase = generatePhase(type);
            phaseStartMeasure = measure;
            
            const phaseTextEl = document.getElementById('phaseText');
            if (phaseTextEl) phaseTextEl.innerText = currentPhase.name;
            
            const rampTime = currentPhase.name.includes("VELOCITY") ? 0.1 : 4.0;
            const targetFreq = currentPhase.filter * 20000 + 200;
            masterFilter.frequency.setTargetAtTime(targetFreq, ac.currentTime, rampTime);
            
            if(type === "DROP" || type === "EVOLVE") playNoiseSweep(ac.currentTime, 2.0);

            // SAVE ON PHASE CHANGE
            saveGame();
        }
        
        const progress = (measure - phaseStartMeasure) / currentPhase.bars;
        const progBar = document.getElementById('progressBar');
        if (progBar) progBar.style.width = (progress * 100) + "%";
        
        // FREQUENT SAVE (Every 4 measures)
        if (measure % 4 === 0) {
            saveGame();
        }
    }
    
    // Generative Motif Logic
    let motif = [0, 2, 4, 7]; // Initial
    
    function mutateMotif() {
        // Change one note in the motif
        const idx = Math.floor(Math.random() * 4);
        motif[idx] = Math.floor(Math.random() * 8); // Pick scale index
    }

    function processStep(step, t) {
        if (!currentPhase) return;

        // Mutate melody every 4 bars
        if (step === 0 && measure % 4 === 0) mutateMotif();

        if (isBoosting) {
            masterFilter.frequency.setTargetAtTime(20000, t, 0.1);
        }

        // 1. KICK
        if (currentPhase.kick && step % 4 === 0) playKick(t);

        // 2. BASS
        if (currentPhase.bass && step % 4 === 2) {
            playBass(t, SCALE[0]);
        }

        // 3. ARP (Evolved)
        if (currentPhase.arp && step % 2 === 0) {
            // Use Motif
            const noteIndex = motif[(step / 2) % 4];
            let freq = SCALE[noteIndex] * 2;
            
            if (isBoosting) freq *= 2;
            if (gameData.cycle > 1 && step % 4 === 1) freq *= 1.5; 
            
            playArp(t, freq);
        }

        // 4. PAD
        if (currentPhase.pad && step === 0) {
            playPad(t, SCALE[0]/2, 2.0); // F2
        }
        
        // 5. LEAD (New Layer)
        if (currentPhase.lead && step % 8 === 0) {
             const leadNote = SCALE[motif[0] % SCALE.length] * 4;
             playLead(t, leadNote);
        }
    }

    // --- INIT ---
    // Start Auto-Save Interval
    setInterval(saveGame, 1000); // Save every second

    loadGame();

    document.getElementById('startBtn').addEventListener('click', () => {
        const ui = document.getElementById('ui');
        ui.style.opacity = 0;
        setTimeout(() => ui.style.display = 'none', 800);
        
        document.getElementById('hudTop').style.opacity = 1;
        document.getElementById('hudBottom').style.opacity = 1;

        init3D();
        initAudio();
        
        if(ac.state === 'suspended') ac.resume();
        isPlaying = true;
        nextNoteTime = ac.currentTime + 0.1;
        
        updateProgression();
        
        schedule();
        animate();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
        resetGame();
    });

</script>
</body>
</html>
