<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ENDORPHIN: STORM EVOLUTION</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Segoe UI', sans-serif; cursor: crosshair; 
            user-select: none;
        }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            background: rgba(0,0,0,0.85);
            transition: opacity 0.5s;
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #fff; font-size: 6vw; margin: 0; line-height: 0.9;
            text-transform: uppercase; font-weight: 900; letter-spacing: -2px;
            background: linear-gradient(to bottom, #fff, #ff00de);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px #ff00de);
            animation: pulse 2s infinite;
        }

        .subtitle {
            color: #00ffff; font-size: 1.5rem; letter-spacing: 5px; margin-top: 20px;
            text-transform: uppercase; font-weight: bold; text-shadow: 0 0 10px #00ffff;
        }

        #startBtn {
            margin-top: 60px;
            background: transparent; color: #fff; border: 2px solid #fff; 
            padding: 20px 80px; font-size: 1.2rem; font-weight: 900; 
            cursor: pointer; text-transform: uppercase; letter-spacing: 5px;
            box-shadow: 0 0 30px #fff; transition: all 0.1s;
        }
        #startBtn:hover { background: #fff; color: #000; box-shadow: 0 0 60px #00ffff; transform: scale(1.05); }

        .hud-top {
            position: absolute; top: 30px; width: 100%; text-align: center;
            z-index: 10; pointer-events: none; opacity: 0; transition: opacity 1s;
        }
        
        .evolution-bar-container {
            width: 300px; height: 6px; background: #222; margin: 10px auto;
            border: 1px solid #555; transform: skewX(-20deg);
        }
        .evolution-bar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #00ffff, #ff00ff, #ffffff);
            box-shadow: 0 0 20px #ff00ff; transition: width 0.1s linear;
        }
        .hud-text {
            color: #fff; font-size: 0.8rem; letter-spacing: 3px; text-shadow: 0 0 5px #fff;
        }

        .hint {
            position: absolute; bottom: 100px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.5); font-size: 1rem; font-weight: bold; letter-spacing: 2px;
            pointer-events: none; opacity: 0; transition: opacity 1s;
        }

        @keyframes pulse {
            0% { filter: drop-shadow(0 0 20px #ff00de); }
            50% { filter: drop-shadow(0 0 50px #ff00de); }
            100% { filter: drop-shadow(0 0 20px #ff00de); }
        }
    </style>
</head>
<body>

<div id="canvas-container"></div>

<div class="ui-layer" id="ui">
    <h1>ENDORPHIN<br>STORM</h1>
    <div class="subtitle">Mouse Driven Evolution</div>
    <button id="startBtn">IGNITE STORM</button>
</div>

<div class="hud-top" id="hud">
    <div class="hud-text">EVOLUTION STAGE</div>
    <div class="evolution-bar-container"><div class="evolution-bar" id="evoBar"></div></div>
    <div class="hud-text" id="statusText">DORMANT</div>
</div>

<div class="hint" id="hint">MOVE MOUSE UP TO EVOLVE</div>

<!-- VERTEX SHADER: The Storm Engine -->
<script type="x-shader/x-vertex" id="vShader">
    varying vec2 vUv;
    varying vec3 vColor;
    varying float vAlpha;
    varying float vDist;

    uniform float uTime;
    uniform float uSpeed;
    uniform float uBass;     
    uniform float uEvo; // Evolution 0.0 - 1.0
    uniform vec2 uMouse;

    attribute float aSize;
    attribute vec3 aColor;
    attribute float aOffset; 
    attribute float aAngle;

    void main() {
        vUv = uv;
        vec3 pos = position;
        
        // 1. Infinite Tunnel Movement
        float zPos = mod(pos.z + uTime * uSpeed + aOffset, 1000.0) - 800.0;
        pos.z = zPos;

        // 2. Storm Twist (Controlled by Mouse X)
        float twist = zPos * 0.005 * (uMouse.x * 2.0);
        float s = sin(twist);
        float c = cos(twist);
        float nx = pos.x * c - pos.y * s;
        float ny = pos.x * s + pos.y * c;
        pos.x = nx;
        pos.y = ny;

        // 3. Evolution Expansion
        // As uEvo increases, the tunnel expands and becomes chaotic
        float chaos = sin(uTime * 10.0 + pos.z * 0.1) * uEvo * 5.0;
        pos.x += chaos;
        pos.y += chaos;

        // 4. Bass Pulse (Heartbeat)
        float pulse = 1.0 + uBass * 0.3 * uEvo; // Bass effect stronger at high evo
        pos.xy *= pulse;

        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
        
        // Size Attenuation
        gl_PointSize = (aSize * (1.0 + uEvo * 2.0)) * (300.0 / -mvPosition.z);
        gl_Position = projectionMatrix * mvPosition;
        
        // Pass to fragment
        vColor = aColor;
        vDist = zPos;
        
        // Evolution Color Shift inside Vertex
        if (uEvo > 0.8) {
            // White hot core at max evolution
            vColor = mix(vColor, vec3(1.0), (uEvo - 0.8) * 5.0);
        }
    }
</script>

<!-- FRAGMENT SHADER: Neon Plasma -->
<script type="x-shader/x-fragment" id="fShader">
    varying vec3 vColor;
    varying float vDist;
    
    uniform float uEvo;
    uniform float uBass;

    void main() {
        vec2 uv = gl_PointCoord.xy - 0.5;
        float dist = length(uv);
        
        // Hard Circle
        if (dist > 0.5) discard;
        
        // Glow gradient
        float glow = 1.0 - (dist * 2.0);
        glow = pow(glow, 2.0);
        
        // Color Modulation by Evolution
        vec3 finalColor = vColor;
        
        // At high evolution, add "Electricity" (random flashes simulated by Bass)
        if (uEvo > 0.5) {
             finalColor += vec3(uBass * 0.5);
        }
        
        // Distance Fog
        float alpha = smoothstep(-900.0, -700.0, vDist) * (1.0 - smoothstep(100.0, 200.0, vDist));

        gl_FragColor = vec4(finalColor * (1.0 + uEvo), alpha * glow);
    }
</script>

<script>
    // --- GLOBAL VARIABLES ---
    let isPlaying = false;
    let evolution = 0; // 0.0 to 1.0 (controlled by mouse Y)
    let mouseX = 0; // -1 to 1 (controlled by mouse X)
    let targetEvolution = 0;
    
    // Three.js
    let scene, camera, renderer, clock;
    let tunnelSystem, uniforms;
    
    // Audio
    let ac, master, filter, limiter, analyser;
    let reverb;
    let audioLoopId;
    
    // Sequencer
    let nextNoteTime = 0;
    let step = 0;

    // --- 3D ENGINE ---
    function init3D() {
        const container = document.getElementById('canvas-container');
        clock = new THREE.Clock();
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 2000);
        camera.position.z = 100;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        container.appendChild(renderer.domElement);

        // PARTICLE SYSTEM
        const geo = new THREE.BufferGeometry();
        const count = 15000;
        const pos = [];
        const sizes = [];
        const colors = [];
        const offsets = [];
        const angles = [];

        const c1 = new THREE.Color(0x00ffff); // Cyan
        const c2 = new THREE.Color(0xff00ff); // Magenta
        const c3 = new THREE.Color(0x0000ff); // Deep Blue

        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const r = 20 + Math.random() * 80; // Wide tunnel
            const x = Math.cos(angle) * r;
            const y = Math.sin(angle) * r;
            const z = (Math.random() - 0.5) * 2000;
            
            pos.push(x, y, z);
            sizes.push(Math.random() * 4.0 + 1.0);
            offsets.push(Math.random() * 1000);
            angles.push(angle);

            // Gradient Mix
            const mixVal = Math.random();
            const col = mixVal < 0.5 ? c1.clone().lerp(c3, mixVal*2) : c3.clone().lerp(c2, (mixVal-0.5)*2);
            colors.push(col.r, col.g, col.b);
        }

        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        geo.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        geo.setAttribute('aOffset', new THREE.Float32BufferAttribute(offsets, 1));
        geo.setAttribute('aAngle', new THREE.Float32BufferAttribute(angles, 1));

        uniforms = {
            uTime: { value: 0 },
            uSpeed: { value: 50 },
            uBass: { value: 0 },
            uEvo: { value: 0 },
            uMouse: { value: new THREE.Vector2(0, 0) }
        };

        const mat = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            uniforms: uniforms,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        tunnelSystem = new THREE.Points(geo, mat);
        scene.add(tunnelSystem);

        window.addEventListener('resize', onWindowResize);
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('touchmove', onTouchMove, {passive: false});
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(e) {
        // X controls Twist (-1 to 1)
        mouseX = (e.clientX / window.innerWidth) * 2 - 1;
        
        // Y controls Evolution (0 at bottom, 1 at top)
        // Inverted so moving UP increases evolution
        targetEvolution = 1.0 - (e.clientY / window.innerHeight);
        
        // Clamp for safety
        targetEvolution = Math.max(0, Math.min(1, targetEvolution));
    }

    function onTouchMove(e) {
        e.preventDefault();
        const t = e.touches[0];
        mouseX = (t.clientX / window.innerWidth) * 2 - 1;
        targetEvolution = 1.0 - (t.clientY / window.innerHeight);
        targetEvolution = Math.max(0, Math.min(1, targetEvolution));
    }

    function animate() {
        requestAnimationFrame(animate);
        if(!clock) return;
        
        const time = clock.getElapsedTime();
        
        // Smooth Evolution Transition
        evolution += (targetEvolution - evolution) * 0.05;
        
        // Update Visual Params
        uniforms.uTime.value = time;
        // Speed increases with Evolution (50 -> 600)
        uniforms.uSpeed.value = 50 + (evolution * 550);
        uniforms.uEvo.value = evolution;
        uniforms.uMouse.value.set(mouseX, 0);

        // Audio Reactivity
        if(analyser) {
            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);
            const bass = data[2] / 255.0; 
            uniforms.uBass.value += (bass - uniforms.uBass.value) * 0.3;
            
            // Camera Shake on Bass + High Evolution
            if (bass > 0.7 && evolution > 0.5) {
                const shake = (evolution - 0.5) * 2.0;
                camera.position.x = (Math.random()-0.5) * shake;
                camera.position.y = (Math.random()-0.5) * shake;
            }
        }
        
        // Camera Roll based on Mouse X
        camera.rotation.z += (-mouseX * 0.5 - camera.rotation.z) * 0.05;

        renderer.render(scene, camera);
        
        // Update HUD
        updateHUD();
    }

    function updateHUD() {
        const bar = document.getElementById('evoBar');
        const txt = document.getElementById('statusText');
        
        bar.style.width = (evolution * 100) + '%';
        
        if(evolution < 0.2) {
            txt.innerText = "DORMANT"; bar.style.background = "#00ffff";
            document.getElementById('hint').style.opacity = 1;
        } else if(evolution < 0.5) {
            txt.innerText = "AWAKENING"; bar.style.background = "linear-gradient(90deg, #00ffff, #ff00ff)";
            document.getElementById('hint').style.opacity = 0;
        } else if(evolution < 0.8) {
            txt.innerText = "SURGE"; bar.style.background = "#ff00ff";
        } else {
            txt.innerText = "CRITICAL MASS"; bar.style.background = "#ffffff";
            txt.style.color = "#fff"; txt.style.textShadow = "0 0 10px #fff";
        }
    }

    // --- AUDIO ENGINE ---
    // F# Minor: F# A C# (Bass), Leads F# G# A B C# D E
    const ROOT = 46.25; 
    const SCALE_FREQS = [46.25, 55.0, 65.41, 82.41, 98.0, 110.0, 130.81]; 

    function initAudio() {
        ac = new (window.AudioContext || window.webkitAudioContext)();
        master = ac.createGain();
        master.gain.value = 0.5;

        masterFilter = ac.createBiquadFilter();
        masterFilter.type = 'lowpass';
        masterFilter.frequency.value = 200; 
        masterFilter.Q.value = 4;

        limiter = ac.createDynamicsCompressor();
        limiter.threshold.value = -3;
        limiter.ratio.value = 20;

        // Reverb
        const len = ac.sampleRate * 2.5;
        const buf = ac.createBuffer(2, len, ac.sampleRate);
        for(let i=0; i<len; i++) {
            let d = Math.pow(1 - i/len, 2);
            buf.getChannelData(0)[i] = (Math.random()*2-1)*d;
            buf.getChannelData(1)[i] = (Math.random()*2-1)*d;
        }
        reverb = ac.createConvolver();
        reverb.buffer = buf;
        const revMix = ac.createGain();
        revMix.gain.value = 0.4;

        master.connect(masterFilter);
        masterFilter.connect(limiter);
        limiter.connect(ac.destination);
        masterFilter.connect(reverb);
        reverb.connect(revMix);
        revMix.connect(limiter);

        analyser = ac.createAnalyser();
        analyser.fftSize = 128;
        limiter.connect(analyser);
    }

    // --- INSTRUMENTS ---
    function playKick(t) {
        const osc = ac.createOscillator();
        const g = ac.createGain();
        osc.frequency.setValueAtTime(150, t);
        osc.frequency.exponentialRampToValueAtTime(40, t + 0.1);
        g.gain.setValueAtTime(1.2, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
        osc.connect(g); g.connect(master);
        osc.start(t); osc.stop(t+0.3);
    }

    function playBass(t, freq) {
        const osc = ac.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq, t);
        const f = ac.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.setValueAtTime(400, t);
        f.frequency.exponentialRampToValueAtTime(100, t + 0.2);
        const g = ac.createGain();
        g.gain.setValueAtTime(0.6, t);
        g.gain.linearRampToValueAtTime(0, t+0.2);
        osc.connect(f); f.connect(g); g.connect(master);
        osc.start(t); osc.stop(t+0.2);
    }

    function playLead(t, freq) {
        // SuperSaw Lead
        const g = ac.createGain();
        g.gain.setValueAtTime(0, t);
        g.gain.linearRampToValueAtTime(0.15, t+0.05);
        g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
        
        [-10, 0, 10].forEach(d => {
            const o = ac.createOscillator();
            o.type = 'sawtooth';
            o.frequency.value = freq;
            o.detune.value = d;
            o.connect(g);
            o.start(t); o.stop(t+0.2);
        });
        g.connect(masterFilter);
    }
    
    function playHiHat(t) {
        const b = ac.createBuffer(1, ac.sampleRate*0.05, ac.sampleRate);
        const d = b.getChannelData(0);
        for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
        const src = ac.createBufferSource();
        src.buffer = b;
        const f = ac.createBiquadFilter();
        f.type='highpass'; f.frequency.value=6000;
        const g = ac.createGain();
        g.gain.value = 0.2;
        src.connect(f); f.connect(g); g.connect(master);
        src.start(t);
    }

    // --- SEQUENCER ---
    function schedule() {
        const tempo = 140;
        const secPer16th = 60/tempo/4;
        const lookahead = 0.1;

        while(nextNoteTime < ac.currentTime + lookahead) {
            processStep(step, nextNoteTime);
            nextNoteTime += secPer16th;
            step = (step + 1) % 16;
        }
        if(isPlaying) setTimeout(schedule, 25);
    }

    function processStep(s, t) {
        // GLOBAL EVOLUTION CONTROL
        // Map evolution (0-1) to filter cutoff (200 - 15000)
        const targetFreq = 200 + (Math.pow(evolution, 2) * 14800);
        masterFilter.frequency.setTargetAtTime(targetFreq, t, 0.1);

        // 1. KICK (Always on)
        if (s % 4 === 0) playKick(t);

        // 2. BASS (Offbeat) - Gets more complex with Evo
        if (evolution > 0.1) {
            if (s % 4 === 2) playBass(t, SCALE_FREQS[0]);
            if (evolution > 0.6 && s % 4 === 3) playBass(t, SCALE_FREQS[0]); // Double kick feel
        }

        // 3. LEAD / ARP (Evolution controlled)
        if (evolution > 0.3) {
            // Pattern density increases with evo
            let play = false;
            if (s % 4 === 0) play = true; // Quarter notes
            if (evolution > 0.5 && s % 2 === 0) play = true; // 8th notes
            if (evolution > 0.8) play = true; // 16th notes (Full storm)

            if (play) {
                // Procedural melody
                const noteIdx = Math.floor(Math.sin(s * 1.5 + evolution * 10) * 3 + 3);
                let freq = SCALE_FREQS[noteIdx % SCALE_FREQS.length] * 2;
                if (evolution > 0.9) freq *= 2; // High octave scream
                playLead(t, freq);
            }
        }
        
        // 4. HI-HATS (High energy)
        if (evolution > 0.4 && s % 2 === 0) playHiHat(t); // 8ths
        if (evolution > 0.7 && s % 1 === 0) playHiHat(t); // 16ths
    }

    // --- INIT ---
    document.getElementById('startBtn').addEventListener('click', () => {
        document.getElementById('ui').style.opacity = 0;
        setTimeout(() => document.getElementById('ui').style.display = 'none', 500);
        document.getElementById('hud').style.opacity = 1;
        document.getElementById('hint').style.opacity = 1;

        init3D();
        initAudio();
        
        if (ac.state === 'suspended') ac.resume();
        isPlaying = true;
        nextNoteTime = ac.currentTime + 0.1;
        
        schedule();
        animate();
    });

</script>
</body>
</html>
